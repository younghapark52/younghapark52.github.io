---
title: "Codeforces Round 1065 (Div. 3)"
date: 2025-11-23
---

# A

완전탐색으로 해결했습니다. 에디토리얼 풀이는 조금 다른데, 별로더라고요.

# B

수식을 잘 정리하면 결국 $\lvert a_n - a_1 \rvert$의 최솟값을 구하는 문제입니다.

$a_n$, $a_1$ 둘 다 -1인 경우, $a_n$만 -1인 경우, $a_1$만 -1인 경우로 나누어 해결할 수 있습니다.

사전식 순서로 가장 앞에 오는 것을 출력해야 함에 유의합시다!

# C1

DP인 줄 알고 삽질했는데... XOR 연산의 성질을 잘 이해하는지 묻는 문제였습니다.

전체를 XOR한 값이 0이라면, 무승부입니다. (나의 최종점수 = 상대의 최종점수)

$a_i \not= b_i$를 만족하는 i-th 턴 중, 가장 마지막 턴을 가져가는 사람이 이깁니다.

$a_i$와 $b_i$를 swap하는 것은 결국 나의 최종점수와 상대의 최종점수를 바꾸는 것과 마찬가지이기 때문이죠.

**보충설명**

전체를 XOR한 값이 1이라는 것은, 전체에서 1이 홀수번 등장했다는 것을 의미합니다.

홀수 = 짝수 + 홀수이고, 1을 홀수개 가져간 사람이 자신의 최종점수가 1이 되어 승리합니다.

결국 마지막 1을 누가 가져가느냐의 싸움으로 이해할 수 있습니다.

# C2

전체를 XOR한 값의 MSB 인덱스를 k라고 합시다.

이 k번 비트를 누가 가져가느냐에 따라 게임의 승패가 결정됩니다.

나머지는 C1 문제와 본질적으로 동일합니다.

MSB 인덱스 구하기, k번 비트 확인하기 등 간단한 비트연산 코드를 작성해야 합니다.

# D

u, v가 트리의 간선을 이룬다면 다음 두 가지를 만족합니다.

- u < v
- p에서 u가 v보다 먼저 등장한다.

다음 두 배열을 정의합니다.

- pre[i] = "$p_1,\cdots,p_i$ 중 최솟값"
- suf[i] = "$p_i,\cdots,p_n$ 중 최댓값"

그리고 모든 i에 대해 pre[i-1] > suf[i]인 i가 단 하나라도 존재하면 트리를 구성할 수 없습니다.

... 왜 그럴까요? 사실 이 부분을 많이 고민했는데, 생각보다 간단합니다.

트리에서 임의의 정점쌍에 대해 두 정점 사이에는 반드시 경로가 존재합니다.

그런데 만약 pre[i-1] > suf[i]인 i가 단 하나라도 있다면?

{p[1],...,p[i-1]}, {p[i],...,p[n]} 두 정점 집합 사이에 간선이 생기지 않습니다.

<br>

그렇다면 모든 i에 대해 pre[i-1] < suf[i]라면, 트리가 구성된다는 것을 어떻게 보장할 수 있을까요?

{p[1],...,p[i-1]}, {p[i],...,p[n]} 두 집합에 대해,

pre[i-1]은 p[i-1]보다 작고, 먼저 등장합니다. 마찬가지로 suf[i]는 p[i]보다 크고, 이후에 등장합니다.

따라서 p[i-1], pre[i-1] 사이 간선이 존재하고, suf[i], p[i] 사이 간선이 존재합니다.

그리고 모든 i에 대해 pre[i-1], suf[i] 사이 간선은 존재합니다.

따라서 임의의 i에 대해 p[i-1]->p[i] 경로는 반드시 존재합니다.

---

# 후기

나름 논리적으로 작성하려고 노력했는데, 아직 많이 부족한 것 같네요 ㅠ

이번 div3 출제자가 [토키와다이의 레일건](https://codeforces.com/profile/reirugan)이었는데, 즐겁게 참여했습니다. (어과초 매우 재밌게 보는 중)
